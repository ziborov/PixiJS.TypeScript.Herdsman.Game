{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://pixijs_typescript_herdsman_game/./src/styles.css","webpack://pixijs_typescript_herdsman_game/./src/Animal.ts","webpack://pixijs_typescript_herdsman_game/./src/HuntingScene.ts","webpack://pixijs_typescript_herdsman_game/./src/Particle.ts","webpack://pixijs_typescript_herdsman_game/./src/Player.ts","webpack://pixijs_typescript_herdsman_game/./src/Projectile.ts","webpack://pixijs_typescript_herdsman_game/./src/SceneManager.ts","webpack://pixijs_typescript_herdsman_game/./src/ScoreBar.ts","webpack://pixijs_typescript_herdsman_game/./src/Settings.ts","webpack://pixijs_typescript_herdsman_game/./src/StartModal.ts","webpack://pixijs_typescript_herdsman_game/./src/Yard.ts","webpack://pixijs_typescript_herdsman_game/./src/app.ts","webpack://pixijs_typescript_herdsman_game/./src/logger.ts","webpack://pixijs_typescript_herdsman_game/webpack/bootstrap","webpack://pixijs_typescript_herdsman_game/webpack/runtime/chunk loaded","webpack://pixijs_typescript_herdsman_game/webpack/runtime/define property getters","webpack://pixijs_typescript_herdsman_game/webpack/runtime/global","webpack://pixijs_typescript_herdsman_game/webpack/runtime/hasOwnProperty shorthand","webpack://pixijs_typescript_herdsman_game/webpack/runtime/make namespace object","webpack://pixijs_typescript_herdsman_game/webpack/runtime/node module decorator","webpack://pixijs_typescript_herdsman_game/webpack/runtime/jsonp chunk loading","webpack://pixijs_typescript_herdsman_game/webpack/before-startup","webpack://pixijs_typescript_herdsman_game/webpack/startup","webpack://pixijs_typescript_herdsman_game/webpack/after-startup"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Animal = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst Settings_1 = require(\"./Settings\");\nclass Animal extends pixi_js_1.Sprite {\n    constructor(options) {\n        super();\n        this.isProjectile = true;\n        this.app = options.app;\n        this.radius = options.radius;\n        this.vx = options.vx;\n        this.vy = options.vy;\n        this.colorIndex = options.colorIndex;\n        this.colorStr = \"0xffffff\";\n        this.movinDirection = true; //Increase\n        this.inPlayerGroup = false;\n        this.playerGroupNumber = 0;\n        this.playerX = 0;\n        this.playerY = 0;\n        this.setup(options);\n    }\n    setup(options) {\n        let texture = Animal.textureCache;\n        if (texture == null) {\n            const circle = new pixi_js_1.Graphics();\n            circle.beginFill(0xffffff);\n            circle.drawCircle(0, 0, this.radius);\n            circle.endFill();\n            circle.cacheAsBitmap = true;\n            texture = options.app.renderer.generateTexture(circle);\n            Animal.textureCache = texture;\n        }\n        this.texture = texture;\n        this.scale.set(options.radius * 2 / texture.width, options.radius * 2 / texture.height);\n        //const colorStr = Animal.interpolateColors(Math.random())\n        this.colorStr = Settings_1.Settings.animalColor[this.colorIndex];\n        this.tint = Number.parseInt(this.colorStr, 16);\n    }\n    update() {\n        if (!this.inPlayerGroup) {\n            if (this.movinDirection) {\n                this.x = this.x + this.vx;\n                this.y = this.y + this.vy;\n            }\n            else {\n                this.x = this.x - this.vx;\n                this.y = this.y - this.vy;\n            }\n        }\n        else {\n            switch (this.playerGroupNumber) {\n                case 0:\n                    break;\n                case 1:\n                    this.x = this.playerX;\n                    this.y = this.playerY - 80;\n                    break;\n                case 2:\n                    this.x = this.playerX + 60;\n                    this.y = this.playerY - 60;\n                    break;\n                case 3:\n                    this.x = this.playerX + 80;\n                    this.y = this.playerY;\n                    break;\n                case 4:\n                    this.x = this.playerX + 60;\n                    this.y = this.playerY + 60;\n                    break;\n                case 5:\n                    this.x = this.playerX;\n                    this.y = this.playerY + 80;\n                    break;\n                case 6:\n                    this.x = this.playerX - 60;\n                    this.y = this.playerY + 60;\n                    break;\n                case 7:\n                    this.x = this.playerX - 80;\n                    this.y = this.playerY;\n                    break;\n                case 8:\n                    this.x = this.playerX - 60;\n                    this.y = this.playerY - 60;\n                    break;\n                default:\n                    console.log(`Error playerGroupNumber: ${this.playerGroupNumber}`);\n            }\n        }\n    }\n    isOutOfViewport({ left, top, right, bottom }) {\n        const pLeft = this.x - this.radius;\n        const pTop = this.y - this.radius;\n        const pRight = this.x + this.radius;\n        const pBottom = this.y + this.radius;\n        if (pRight < left) {\n            return true;\n        }\n        if (pLeft > right) {\n            return true;\n        }\n        if (pBottom < top) {\n            return true;\n        }\n        if (pTop > bottom) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.Animal = Animal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HuntingScene = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst gsap_1 = __importDefault(require(\"gsap\"));\nconst ScoreBar_1 = require(\"./ScoreBar\");\nconst Player_1 = require(\"./Player\");\nconst Yard_1 = require(\"./Yard\");\nconst logger_1 = require(\"./logger\");\nconst Projectile_1 = require(\"./Projectile\");\nconst Animal_1 = require(\"./Animal\");\nconst Particle_1 = require(\"./Particle\");\nconst StartModal_1 = require(\"./StartModal\");\nconst Settings_1 = require(\"./Settings\");\nclass HuntingScene extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.gameEnded = false;\n        this.elapsedFrames = 0;\n        this.ids = 0;\n        this.backgroundSettings = {\n            color: Settings_1.Settings.backgroundColor\n        };\n        this.startGame = () => {\n            this.startModal.visible = false;\n            this.scoreBar.clearScore();\n            while (this.projectilesContainer.children[0] != null) {\n                this.projectilesContainer.removeChild(this.projectilesContainer.children[0]);\n            }\n            while (this.animalsContainer.children[0] != null) {\n                this.animalsContainer.removeChild(this.animalsContainer.children[0]);\n            }\n            while (this.particlesContainer.children[0] != null) {\n                this.particlesContainer.removeChild(this.particlesContainer.children[0]);\n            }\n            this.gameEnded = false;\n        };\n        this.setup(options);\n        this.draw(options);\n        this.addEventLesteners();\n        this.viewWidth_2 = 0;\n        this.viewHeight_2 = 0;\n        this.setInYardShow = false;\n    }\n    init({ app }) {\n        this.app = app;\n    }\n    setup({ viewWidth, viewHeight }) {\n        this.background = new pixi_js_1.Graphics();\n        this.addChild(this.background);\n        this.yard = new Yard_1.Yard({\n            yardX: 0,\n            yardY: 0,\n            yardRadius: Settings_1.Settings.yardRadius,\n            yardFillColor: Settings_1.Settings.yardColor,\n            yardLineColor: Settings_1.Settings.yardLineColor\n        });\n        this.yard.position.set(viewWidth / 2, viewHeight / 2);\n        this.addChild(this.yard);\n        this.animalsContainer = new pixi_js_1.ParticleContainer(2000, { scale: true, position: true, tint: true });\n        this.addChild(this.animalsContainer);\n        this.animalsInPlayerGroupContainer = new pixi_js_1.ParticleContainer(2000, { scale: true, position: true, tint: true });\n        this.addChild(this.animalsInPlayerGroupContainer);\n        this.projectilesContainer = new pixi_js_1.ParticleContainer(2000, { scale: true, position: true, tint: true });\n        this.addChild(this.projectilesContainer);\n        this.particlesContainer = new pixi_js_1.ParticleContainer(2000, { scale: true, position: true, tint: true });\n        this.addChild(this.particlesContainer);\n        this.scoreBar = new ScoreBar_1.ScoreBar();\n        this.addChild(this.scoreBar);\n        this.player = new Player_1.Player({\n            radius: Settings_1.Settings.playerRadius,\n            fillColor: Settings_1.Settings.playerColor,\n            damage: 20,\n            health: 100\n        });\n        this.player.position.set(viewWidth / 2, viewHeight / 2);\n        this.addChild(this.player);\n        this.startModal = new StartModal_1.StartModal({ viewWidth, viewHeight });\n        this.startModal.visible = false;\n        this.addChild(this.startModal);\n    }\n    draw({ viewWidth, viewHeight }) {\n        this.background.beginFill(this.backgroundSettings.color);\n        this.background.drawRect(0, 0, viewWidth, viewHeight);\n        this.background.endFill();\n    }\n    handleResize(options) {\n        this.centerPlayer(options);\n        this.resizeBackground(options);\n        this.centerModal(options);\n    }\n    centerPlayer({ viewWidth, viewHeight }) {\n        this.player.x = viewWidth / 2;\n        this.player.y = viewHeight / 2;\n        this.viewWidth_2 = this.player.x;\n        this.viewHeight_2 = this.player.y;\n        this.yard.x = viewWidth / 2;\n        this.yard.y = viewHeight / 2;\n    }\n    centerModal({ viewWidth, viewHeight }) {\n        // this.startModal.anchor\n        this.startModal.position.set(viewWidth / 2 - this.startModal.boxOptions.width / 2, viewHeight / 2 - this.startModal.boxOptions.height / 2);\n    }\n    resizeBackground({ viewWidth, viewHeight }) {\n        (0, logger_1.logLayout)(`bgw=${this.background.width} bgh=${this.background.height} vw=${viewWidth} vh=${viewHeight}`);\n        this.background.width = viewWidth;\n        this.background.height = viewHeight;\n    }\n    handleUpdate(deltaMS) {\n        if (this.gameEnded) {\n            return;\n        }\n        this.elapsedFrames += 1;\n        const { x, y, width, height } = this;\n        const left = x;\n        const top = y;\n        const right = x + width;\n        const bottom = y + height;\n        for (const child of this.particlesContainer.children) {\n            const particle = child;\n            particle.update();\n            if (particle.alpha <= 0) {\n                this.particlesContainer.removeChild(particle);\n                (0, logger_1.logParticle)(`Removed particle alpha (${this.particlesContainer.children.length})`);\n            }\n            else if (particle.isOutOfViewport({ left, top, right, bottom })) {\n                this.particlesContainer.removeChild(particle);\n                (0, logger_1.logParticle)(`Removed particle out of viewport (${this.particlesContainer.children.length})`);\n            }\n        }\n        for (const child of this.animalsContainer.children) {\n            const animal = child;\n            animal.update();\n            if (animal.isOutOfViewport({ left, top, right, bottom })) {\n                animal.movinDirection = !animal.movinDirection;\n                animal.update();\n            }\n        }\n        if (this.player.visible) {\n            for (const child of this.animalsInPlayerGroupContainer.children) {\n                const animal = child;\n                animal.playerX = this.player.position.x;\n                animal.playerY = this.player.position.y;\n                animal.update();\n            }\n        }\n        for (const child of this.projectilesContainer.children) {\n            const projectile = child;\n            projectile.update(deltaMS);\n            if (!this.player.visible) {\n                for (const child of this.animalsInPlayerGroupContainer.children) {\n                    const animal = child;\n                    animal.playerX = projectile.position.x;\n                    animal.playerY = projectile.position.y;\n                    animal.update();\n                }\n            }\n            if (projectile.isOutOfViewport({ left, top, right, bottom })) {\n                this.projectilesContainer.removeChild(projectile);\n                this.player.visible = true;\n                (0, logger_1.logProjectile)(`Removed projectile out of viewport (${this.projectilesContainer.children.length})`);\n            }\n            if (projectile.isInsideYard(this.yard)\n                && this.animalsInPlayerGroupContainer.children.length === Settings_1.Settings.playerGroupAnimalMaximum\n                && !this.setInYardShow) {\n                this.setInYardShow = true;\n                this.projectilesContainer.removeChildren();\n                console.log(`Projectile is in yard`);\n                console.log(`this.animalsInPlayerGroupContainer.children.length: ${this.animalsInPlayerGroupContainer.children.length}`);\n                setTimeout(() => {\n                    this.animalsInPlayerGroupContainer.removeChildren();\n                    this.setInYardShow = false;\n                    console.log(`this.animalsInPlayerGroupContainer.children.length: ${this.animalsInPlayerGroupContainer.children.length}`);\n                    this.scoreBar.addScore(Settings_1.Settings.playerGroupAnimalMaximum);\n                }, 500);\n                this.player.visible = true;\n                this.player.x = this.viewWidth_2;\n                this.player.y = this.viewHeight_2;\n            }\n        }\n        const removedProjectileIds = [];\n        for (const child of this.animalsContainer.children) {\n            // detect animal collision with player\n            const animal = child;\n            const distP = Math.hypot(this.yard.x - animal.x, this.yard.y - animal.y);\n            if (distP - animal.radius - this.yard.yardRadius < 0) {\n                animal.movinDirection = !animal.movinDirection;\n                animal.update();\n                //this.endGame()\n                break;\n            }\n            // detect animal collision with projectile\n            for (const _child of this.projectilesContainer.children) {\n                const projectile = _child;\n                if (!projectile.isProjectile) {\n                    continue;\n                }\n                const dist = Math.hypot(projectile.x - animal.x, projectile.y - animal.y);\n                if (dist - animal.radius - projectile.radius < 0) {\n                    this.projectilesContainer.removeChild(projectile);\n                    (0, logger_1.logProjectile)(`Removed projectile hit emeny (${this.projectilesContainer.children.length})`);\n                    removedProjectileIds.push(projectile.id);\n                    //console.log(`colorIndex: ${animal.colorIndex} , radius: ${animal.radius}`)\n                    // update score\n                    this.scoreBar.addScore(100);\n                    this.player.visible = true;\n                    const angleExp = Math.atan2(projectile.y - animal.y, projectile.x - animal.x);\n                    const px = Math.cos(angleExp) * animal.radius + animal.x;\n                    const py = Math.sin(angleExp) * animal.radius + animal.y;\n                    this.player.position.set(px, py);\n                    this.player.visible = true;\n                    const animalColor = Number.parseInt(animal.colorStr, 16);\n                    //console.log(`animalColor: ${animalColor.toString(16)}`)\n                    // create particle Effect\n                    for (let index = 0; index < animal.radius * 3; index++) {\n                        const vx = (Math.random() - 0.5) * 10;\n                        const vy = (Math.random() - 0.5) * 10;\n                        const particle = new Particle_1.Particle({\n                            app: this.app,\n                            radius: 2,\n                            vx,\n                            vy,\n                            fillColor: animalColor\n                        });\n                        particle.position.set(px, py);\n                        this.particlesContainer.addChild(particle);\n                    }\n                    // shrink animal\n                    animal.radius = animal.radius - projectile.radius;\n                    if (animal.radius <= 5) {\n                        if (this.animalsInPlayerGroupContainer.children.length < Settings_1.Settings.playerGroupAnimalMaximum) {\n                            animal.inPlayerGroup = true;\n                            animal.playerX = this.player.position.x;\n                            animal.playerY = this.player.position.y;\n                            //this.animalInGroupLastNumber++\n                            console.log(`this.animalsInPlayerGroupContainer.children.length: ${this.animalsInPlayerGroupContainer.children.length}`);\n                            this.animalsInPlayerGroupContainer.addChild(animal);\n                            animal.playerGroupNumber = this.animalsInPlayerGroupContainer.children.length;\n                        }\n                        else {\n                            this.animalsContainer.removeChild(animal);\n                        }\n                        (0, logger_1.logAnimal)(`Removed animal killed (${this.animalsContainer.children.length})`);\n                    }\n                    else {\n                        this.scoreBar.addScore(projectile.radius);\n                        gsap_1.default.to(animal, {\n                            width: animal.radius * 2,\n                            height: animal.radius * 2\n                        });\n                    }\n                }\n                else {\n                    this.player.visible = false;\n                }\n            }\n        }\n        if (removedProjectileIds.length > 0) {\n            let startIdx = -1;\n            let endIdx = -1;\n            this.projectilesContainer.children.forEach((child, idx) => {\n                const projectileTrail = child;\n                if (!projectileTrail.isProjectile && removedProjectileIds.includes(projectileTrail.mainId)) {\n                    if (startIdx === -1) {\n                        startIdx = idx;\n                    }\n                    endIdx = idx;\n                }\n            });\n            if (startIdx > -1 && endIdx > -1) {\n                this.projectilesContainer.removeChildren(startIdx, endIdx);\n                (0, logger_1.logProjectileTrail)(`Removed projectile trails [${startIdx}:${endIdx}]`);\n            }\n        }\n        if (this.elapsedFrames % 60 === 0) {\n            this.spawnAnimals();\n        }\n    }\n    addEventLesteners() {\n        this.interactive = true;\n        this.on('pointertap', this.handlePointerTap);\n        this.startModal.on('click', this.startGame);\n    }\n    removeEventListeners() {\n        this.interactive = false;\n        this.off('pointertap', this.handlePointerTap);\n        this.startModal.off('click', this.startGame);\n    }\n    handlePointerTap(e) {\n        if (this.gameEnded) {\n            return;\n        }\n        const point = this.toLocal(e.global);\n        (0, logger_1.logPointerEvent)(`${e.type} px=${point.x} py=${point.y}`);\n        const diffY = point.y - this.player.y;\n        const diffX = point.x - this.player.x;\n        // const diff = Math.hypot(diffX, diffY)\n        // const maxDiff = Math.hypot(this.player.x, this.player.y)\n        // const relVelocityFactor = diff / maxDiff\n        const relVelocityFactor = 1;\n        const angle = Math.atan2(diffY, diffX);\n        (0, logger_1.logPointerEvent)(`angle=${angle} diffY=${diffY} diffX=${diffX} relVelocityFactor=${relVelocityFactor}`);\n        const radius = Settings_1.Settings.playerRadius;\n        const velocityAmplifier = 20;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const vx = cos * relVelocityFactor * velocityAmplifier;\n        const vy = sin * relVelocityFactor * velocityAmplifier;\n        const projectile = new Projectile_1.Projectile({\n            id: ++this.ids,\n            app: this.app,\n            radius,\n            fillColor: Settings_1.Settings.playerColor,\n            vx,\n            vy\n        });\n        projectile.anchor.set(0.5, 0.5);\n        projectile.position.set(this.player.x, this.player.y);\n        this.projectilesContainer.addChild(projectile);\n        const trailProjectiles = projectile.BuildTrail();\n        (0, logger_1.logProjectileTrail)(`Trail projectiles (${trailProjectiles.length})`);\n        trailProjectiles.forEach(p => {\n            p.anchor.set(0.5, 0.5);\n            p.position.set(this.player.x, this.player.y);\n            this.projectilesContainer.addChild(p);\n        });\n        (0, logger_1.logProjectile)(`Added (${this.projectilesContainer.children.length})`);\n    }\n    spawnAnimals() {\n        const radMax = 30;\n        const radMin = 15;\n        const rad = Math.floor(radMin + Math.random() * (radMax - radMin + 1));\n        const { width, height } = this.background;\n        const RI = 1 + Math.round(Math.random() * (4 - 1));\n        let x = 0;\n        let y = 0;\n        switch (RI) {\n            case 1:\n                x = width + rad;\n                y = Math.random() * height;\n                break;\n            case 2:\n                x = Math.random() * width;\n                y = 0 - rad;\n                break;\n            case 3:\n                x = 0 - rad;\n                y = Math.random() * height;\n                break;\n            case 4:\n                x = Math.random() * width;\n                y = height + rad;\n                break;\n        }\n        const velMax = 3;\n        const velMin = 1;\n        const velocityAmplifier = velMin + Math.round((velMax - velMin) * Math.random());\n        const angle = Math.atan2(this.player.y - y, this.player.x - x);\n        const vx = Math.cos(angle) * velocityAmplifier;\n        const vy = Math.sin(angle) * velocityAmplifier;\n        const animal = new Animal_1.Animal({\n            app: this.app,\n            radius: rad,\n            vx,\n            vy,\n            colorIndex: Math.trunc(Math.random() * 4)\n        });\n        animal.anchor.set(0.5, 0.5);\n        animal.position.set(x, y);\n        this.animalsContainer.addChild(animal);\n    }\n    endGame() {\n        this.gameEnded = true;\n        this.startModal.scoreText.text = this.scoreBar.score;\n        this.startModal.visible = true;\n    }\n}\nexports.HuntingScene = HuntingScene;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Particle = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass Particle extends pixi_js_1.Sprite {\n    constructor(options) {\n        super();\n        this.isProjectile = true;\n        this.app = options.app;\n        this.radius = options.radius;\n        this.vx = options.vx;\n        this.vy = options.vy;\n        this.setup(options);\n    }\n    setup(options) {\n        let texture = Particle.textureCache;\n        if (texture == null) {\n            const circle = new pixi_js_1.Graphics();\n            circle.beginFill(options.fillColor);\n            circle.drawCircle(0, 0, this.radius);\n            circle.endFill();\n            circle.cacheAsBitmap = true;\n            texture = options.app.renderer.generateTexture(circle);\n            Particle.textureCache = texture;\n        }\n        this.texture = texture;\n        this.scale.set(options.radius * 2 / texture.width, options.radius * 2 / texture.height);\n        this.tint = options.fillColor;\n    }\n    update() {\n        this.x = this.x + this.vx;\n        this.y = this.y + this.vy;\n        this.alpha = this.alpha - 0.01;\n        if (this.alpha < 0) {\n            this.alpha = 0;\n        }\n    }\n    isOutOfViewport({ left, top, right, bottom }) {\n        const pLeft = this.x - this.radius;\n        const pTop = this.y - this.radius;\n        const pRight = this.x + this.radius;\n        const pBottom = this.y + this.radius;\n        if (pRight < left) {\n            return true;\n        }\n        if (pLeft > right) {\n            return true;\n        }\n        if (pBottom < top) {\n            return true;\n        }\n        if (pTop > bottom) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.Particle = Particle;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Player = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass Player extends pixi_js_1.Graphics {\n    constructor(options) {\n        super();\n        this.radius = options.radius;\n        this.damage = options.damage;\n        this.health = options.health;\n        this.fillColor = options.fillColor;\n        this.draw();\n    }\n    draw() {\n        this.beginFill(this.fillColor);\n        this.drawCircle(0, 0, this.radius);\n        this.endFill();\n    }\n}\nexports.Player = Player;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProjectileTrail = exports.Projectile = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nclass Projectile extends pixi_js_1.Sprite {\n    constructor(options) {\n        super();\n        this.isProjectile = true;\n        this.id = options.id;\n        this.app = options.app;\n        this.radius = options.radius;\n        this.vx = options.vx;\n        this.vy = options.vy;\n        this.fillColor = options.fillColor;\n        this.setup(options);\n    }\n    setup(options) {\n        let texture = Projectile.textureCache;\n        if (texture == null) {\n            const circle = new pixi_js_1.Graphics();\n            circle.beginFill(this.fillColor);\n            circle.drawCircle(0, 0, this.radius);\n            circle.endFill();\n            circle.cacheAsBitmap = true;\n            texture = options.app.renderer.generateTexture(circle);\n            Projectile.textureCache = texture;\n        }\n        this.texture = texture;\n    }\n    update() {\n        this.x = this.x + this.vx;\n        this.y = this.y + this.vy;\n    }\n    isOutOfViewport({ left, top, right, bottom }) {\n        const pLeft = this.x - this.radius;\n        const pTop = this.y - this.radius;\n        const pRight = this.x + this.radius;\n        const pBottom = this.y + this.radius;\n        if (pRight < left) {\n            return true;\n        }\n        if (pLeft > right) {\n            return true;\n        }\n        if (pBottom < top) {\n            return true;\n        }\n        if (pTop > bottom) {\n            return true;\n        }\n        return false;\n    }\n    isInsideYard(yard) {\n        const distYard = Math.hypot(yard.x - this.x, yard.y - this.y);\n        if (distYard - this.radius - yard.yardRadius < 0) {\n            return true;\n        }\n        return false;\n    }\n    BuildTrail() {\n        const length = Math.floor(this.radius) * 3;\n        // const length = 1\n        return Array.from({ length }, (_, idx) => {\n            return new ProjectileTrail({\n                mainId: this.id,\n                mainX: this.x,\n                mainY: this.y,\n                texture: this.texture,\n                radius: this.radius - (this.radius - 1) * idx / length,\n                vx: this.vx,\n                vy: this.vy,\n                dt: 0.5 - (0.5 - 0.01) * idx / length,\n                alpha: 0.9 - 0.8 * (idx + 1) / length\n            });\n        });\n    }\n}\nexports.Projectile = Projectile;\nclass ProjectileTrail extends pixi_js_1.Sprite {\n    constructor(options) {\n        var _a, _b, _c;\n        super(options.texture);\n        this.isProjectile = false;\n        this.mainId = options.mainId;\n        this.radius = options.radius;\n        this.mainX = options.mainX;\n        this.mainY = options.mainY;\n        this.vx = options.vx;\n        this.vy = options.vy;\n        this.minDelta = (_a = options.minDelta) !== null && _a !== void 0 ? _a : 0.05;\n        this.dt = (_b = options.dt) !== null && _b !== void 0 ? _b : 0.1;\n        this.tint = 0xffffff;\n        this.alpha = (_c = options.alpha) !== null && _c !== void 0 ? _c : 1;\n        this.scale.set(options.radius * 2 / options.texture.width, options.radius * 2 / options.texture.height);\n    }\n    update(deltaMS) {\n        // const dt = 1 - Math.pow(1 - this.sharpness, deltaMS)\n        const dt = this.dt;\n        this.mainX += this.vx;\n        this.mainY += this.vy;\n        (0, logger_1.logProjectileTrail)(`main(${this.mainX}, ${this.mainY}) cur(${this.x}, ${this.y})`);\n        const dx = Math.abs(this.x - this.mainX);\n        const dy = Math.abs(this.y - this.mainY);\n        (0, logger_1.logProjectileTrail)('dt', dt, 'dx', dx, 'dy', dy, 'mind', this.minDelta);\n        if (dx > this.minDelta) {\n            (0, logger_1.logProjectileTrail)('dx * dt', dx * dt);\n            this.x += this.vx > 0 ? dx * dt : -dx * dt;\n        }\n        else {\n            this.x = this.mainX;\n        }\n        if (dy > this.minDelta) {\n            (0, logger_1.logProjectileTrail)('dy * dt', dy * dt);\n            this.y += this.vy > 0 ? dy * dt : -dy * dt;\n        }\n        else {\n            this.y = this.mainY;\n        }\n    }\n    isOutOfViewport({ left, top, right, bottom }) {\n        const pLeft = this.x - this.radius;\n        const pTop = this.y - this.radius;\n        const pRight = this.x + this.radius;\n        const pBottom = this.y + this.radius;\n        if (pRight < left) {\n            return true;\n        }\n        if (pLeft > right) {\n            return true;\n        }\n        if (pBottom < top) {\n            return true;\n        }\n        if (pTop > bottom) {\n            return true;\n        }\n        return false;\n    }\n    isInsideYard(yard) {\n        const distYard = Math.hypot(yard.x - this.x, yard.y - this.y);\n        if (distYard - this.radius - yard.yardRadius < 0) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.ProjectileTrail = ProjectileTrail;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SceneManager = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nclass DefaultScene extends pixi_js_1.Container {\n    init() { }\n    handleUpdate() { }\n    handleResize() { }\n}\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass SceneManager {\n    constructor() { }\n    static get width() {\n        return window.innerWidth;\n    }\n    static get height() {\n        return window.innerHeight;\n    }\n    static async initialize() {\n        var _a;\n        const app = new pixi_js_1.Application({\n            autoDensity: true,\n            resolution: (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1,\n            width: SceneManager.width,\n            height: SceneManager.height,\n            resizeTo: window\n        });\n        document.body.appendChild(app.view);\n        if (logger_1.logApp.enabled) {\n            (0, logger_1.logApp)('window.app initialized!');\n            window.app = app;\n        }\n        SceneManager.app = app;\n        SceneManager.setupEventLesteners();\n    }\n    static setupEventLesteners() {\n        window.addEventListener('resize', SceneManager.resizeDeBounce);\n        SceneManager.app.ticker.add(SceneManager.updateHandler);\n    }\n    static async changeScene(newScene) {\n        SceneManager.app.stage.removeChild(SceneManager.currentScene);\n        SceneManager.currentScene.destroy();\n        SceneManager.currentScene = newScene;\n        SceneManager.app.stage.addChild(SceneManager.currentScene);\n        SceneManager.currentScene.init({ app: SceneManager.app });\n        SceneManager.resizeHandler();\n    }\n    static resizeDeBounce() {\n        SceneManager.cancelScheduledResizeHandler();\n        SceneManager.scheduleResizeHandler();\n    }\n    static cancelScheduledResizeHandler() {\n        clearTimeout(SceneManager.resizeTimeoutId);\n    }\n    static scheduleResizeHandler() {\n        SceneManager.resizeTimeoutId = setTimeout(() => {\n            SceneManager.cancelScheduledResizeHandler();\n            SceneManager.resizeHandler();\n        }, SceneManager.resizeTimeout);\n    }\n    static resizeHandler() {\n        SceneManager.currentScene.handleResize({\n            viewWidth: SceneManager.width,\n            viewHeight: SceneManager.height\n        });\n    }\n    static updateHandler() {\n        SceneManager.currentScene.handleUpdate(SceneManager.app.ticker.deltaMS);\n    }\n}\nSceneManager.currentScene = new DefaultScene();\nSceneManager.resizeTimeout = 300;\nexports.SceneManager = SceneManager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScoreBar = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass ScoreBar extends pixi_js_1.Container {\n    constructor() {\n        super();\n        this.scoreOptions = {\n            padding: 20,\n            textColor: 0xffffff,\n            textSize: 40\n        };\n        this._score = 0;\n        this.setup();\n    }\n    get score() {\n        return this._score;\n    }\n    setup() {\n        const { scoreOptions } = this;\n        const scoreText = new pixi_js_1.Text(`Score: ${this._score}`, {\n            fontSize: scoreOptions.textSize,\n            fill: scoreOptions.textColor\n        });\n        scoreText.position.set(scoreOptions.padding, scoreOptions.padding);\n        this.addChild(scoreText);\n        this.scoreText = scoreText;\n    }\n    addScore(score) {\n        this._score += Math.round(score);\n        this.scoreText.text = `Score: ${this._score}`;\n    }\n    clearScore() {\n        this._score = 0;\n        this.scoreText.text = `Score: ${this._score}`;\n    }\n}\nexports.ScoreBar = ScoreBar;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Settings = void 0;\nclass Settings {\n}\nSettings.backgroundColor = 0x00C853;\nSettings.yardColor = 0xFFEE58;\nSettings.yardLineColor = 0x263238;\nSettings.yardRadius = 200;\nSettings.playerColor = 0xFF1744;\nSettings.playerRadius = 30;\nSettings.animalColor = [\"0xF8BBD0\", \"0xC5CAE9\", \"0xF0F4C3\", \"0xFFCCBC\"];\nSettings.playerGroupAnimalMaximum = 5; //1..8\nexports.Settings = Settings;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StartModal = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass StartModal extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.boxOptions = {\n            fill: 0xffffff,\n            width: 300,\n            height: 200,\n            borderRadius: 5\n        };\n        this.scoreOptions = {\n            top: -50,\n            textColor: 0x000000,\n            textSize: 40,\n            fontWeight: 'bold'\n        };\n        this.pointsOptions = {\n            top: -10,\n            textColor: 0x000000,\n            textSize: 20\n        };\n        this.buttonOptions = {\n            top: 120,\n            left: 50,\n            width: 200,\n            height: 50,\n            fill: 0x0ea5e9,\n            borderRadius: 10\n        };\n        this.buttonTextOptions = {\n            top: 95,\n            textColor: 0xffffff,\n            textSize: 20\n        };\n        this.setup(options);\n        this.draw(options);\n        this.setupEventListeners();\n    }\n    setup(_) {\n        this.modalBox = new pixi_js_1.Graphics();\n        this.addChild(this.modalBox);\n        const { boxOptions, scoreOptions, pointsOptions, buttonTextOptions } = this;\n        this.scoreText = new pixi_js_1.Text('0', {\n            fontSize: scoreOptions.textSize,\n            fill: scoreOptions.textColor,\n            fontWeight: scoreOptions.fontWeight\n        });\n        this.scoreText.anchor.set(0.5, 0.5);\n        this.scoreText.position.set(boxOptions.width / 2, boxOptions.height / 2 + scoreOptions.top);\n        this.addChild(this.scoreText);\n        this.pointsText = new pixi_js_1.Text('Points', {\n            fontSize: pointsOptions.textSize,\n            fill: pointsOptions.textColor\n        });\n        this.pointsText.anchor.set(0.5, 0.5);\n        this.pointsText.position.set(boxOptions.width / 2, boxOptions.height / 2 + pointsOptions.top);\n        this.addChild(this.pointsText);\n        this.button = new pixi_js_1.Graphics();\n        this.button.interactive = true;\n        this.button.cursor = 'pointer';\n        this.addChild(this.button);\n        this.buttonText = new pixi_js_1.Text('Start Game', {\n            fontSize: buttonTextOptions.textSize,\n            fill: buttonTextOptions.textColor\n        });\n        this.buttonText.anchor.set(0.5, 0.5);\n        this.buttonText.position.set(boxOptions.width / 2, boxOptions.height / 2 / 2 + buttonTextOptions.top);\n        this.button.addChild(this.buttonText);\n    }\n    draw(_) {\n        const { boxOptions, buttonOptions } = this;\n        this.modalBox.beginFill(boxOptions.fill);\n        this.modalBox.drawRoundedRect(0, 0, boxOptions.width, boxOptions.height, boxOptions.borderRadius);\n        this.modalBox.endFill();\n        this.button.beginFill(buttonOptions.fill);\n        this.button.drawRoundedRect(buttonOptions.left, buttonOptions.top, buttonOptions.width, buttonOptions.height, buttonOptions.borderRadius);\n        this.button.endFill();\n    }\n    setupEventListeners() {\n        this.button.on('pointertap', (e) => {\n            this.emit('click', e);\n        });\n    }\n}\nexports.StartModal = StartModal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Yard = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass Yard extends pixi_js_1.Graphics {\n    constructor(options) {\n        super();\n        this.yardX = options.yardX;\n        this.yardY = options.yardY;\n        this.yardRadius = options.yardRadius;\n        this.yardFillColor = options.yardFillColor;\n        this.yardLineColor = options.yardLineColor;\n        this.draw();\n    }\n    draw() {\n        this.lineStyle(10, this.yardLineColor, 1);\n        this.beginFill(this.yardFillColor);\n        this.drawCircle(0, 0, this.yardRadius);\n        //this.drawRect(this.yardX - this.yardWidth / 2, this.yardY - this.yardHeight / 2, this.yardWidth, this.yardHeight)\n        this.endFill();\n    }\n}\nexports.Yard = Yard;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"./styles.css\");\nconst SceneManager_1 = require(\"./SceneManager\");\nconst HuntingScene_1 = require(\"./HuntingScene\");\nasync function run() {\n    const ellipsis = document.querySelector('.ellipsis');\n    if (ellipsis != null) {\n        ellipsis.style.display = 'none';\n    }\n    await SceneManager_1.SceneManager.initialize();\n    await SceneManager_1.SceneManager.changeScene(new HuntingScene_1.HuntingScene({\n        viewWidth: SceneManager_1.SceneManager.width,\n        viewHeight: SceneManager_1.SceneManager.height\n    }));\n}\nrun().catch((err) => {\n    console.error(err);\n    const div = document.createElement('div');\n    const divStack = document.createElement('div');\n    document.body.prepend(div);\n    document.body.prepend(divStack);\n    div.style.color = 'red';\n    div.style.fontSize = '2rem';\n    div.innerText = ((Boolean(err)) && (Boolean(err.message))) ? err.message : err;\n    divStack.style.color = 'red';\n    divStack.style.fontSize = '2rem';\n    divStack.innerText = ((Boolean(err)) && (Boolean(err.stack))) ? err.stack : '';\n});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logProjectileTrail = exports.logParticle = exports.logAnimal = exports.logProjectile = exports.logPointerEvent = exports.logLayout = exports.logApp = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nexports.logApp = (0, debug_1.default)('shooting-app');\nexports.logLayout = (0, debug_1.default)('shooting-layout');\nexports.logPointerEvent = (0, debug_1.default)('shooting-pointer-event');\nexports.logProjectile = (0, debug_1.default)('shooting-projectile');\nexports.logAnimal = (0, debug_1.default)('shooting-enemy');\nexports.logParticle = (0, debug_1.default)('shooting-particle');\nexports.logProjectileTrail = (0, debug_1.default)('shooting-projectile-trail');\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkpixijs_typescript_herdsman_game\"] = self[\"webpackChunkpixijs_typescript_herdsman_game\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendor\"], () => (__webpack_require__(\"./src/app.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}